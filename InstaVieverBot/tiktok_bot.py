import os
import re
import logging
import yt_dlp
import httpx
import asyncio
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeoutError
import ffmpeg
import json
import time

# Налаштування логування
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# Асинхронний кеш для розгорнутих URL
url_cache = {}

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.info("Отримано команду /start")
    await update.message.reply_text("Привіт! Надішли мені посилання на TikTok, і я допоможу завантажити відео!")

async def generate_cookies_with_login():
    """Генерує cookies через авторизацію за логіном і паролем."""
    username = os.getenv('TIKTOK_USERNAME')
    password = os.getenv('TIKTOK_PASSWORD')
    if not username or not password:
        logger.warning("TIKTOK_USERNAME або TIKTOK_PASSWORD не встановлено, cookies не буде створено")
        return False

    logger.info("Генеруємо cookies через авторизацію")
    try:
        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=True)
            context = await browser.new_context(
                user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            )
            page = await context.new_page()
            await page.goto('https://www.tiktok.com/login/phone-or-email/email', timeout=60000)
            await page.wait_for_load_state('networkidle', timeout=60000)
            logger.info("Заповнюємо форму логіну")
            await page.fill('input[name="username"]', username)
            await page.fill('input[name="password"]', password)
            await page.click('button[type="submit"]')
            await page.wait_for_load_state('networkidle', timeout=60000)
            if 'login' in page.url:
                logger.error("Авторизація не вдалася, можливо, некоректний логін/пароль")
                await browser.close()
                return False
            await context.storage_state(path='InstaVieverBot/cookies.json')
            await browser.close()
            logger.info("Cookies успішно збережено в InstaVieverBot/cookies.json")
            return True
    except PlaywrightTimeoutError:
        logger.error("Таймаут під час авторизації через Playwright")
        return False
    except Exception as e:
        logger.error(f"Помилка під час авторизації через Playwright: {e}", exc_info=True)
        return False

async def convert_cookies_to_netscape():
    """Конвертує cookies.json у формат Netscape для yt-dlp."""
    cookies_file = 'InstaVieverBot/cookies.json'
    cookies_txt = 'InstaVieverBot/cookies.txt'
    if not os.path.exists(cookies_file):
        logger.warning(f"Файл {cookies_file} не знайдено")
        return False

    try:
        with open(cookies_file, 'r') as f:
            data = json.load(f)
            cookies = data.get('cookies', [])
            if not cookies:
                logger.warning(f"Файл {cookies_file} порожній або не містить cookies")
                return False
        with open(cookies_txt, 'w') as f:
            f.write('# Netscape HTTP Cookie File\n# This file is generated by the bot. Do not edit.\n\n')
            for cookie in cookies:
                if cookie.get('domain') and 'tiktok.com' in cookie['domain']:
                    f.write(f"{cookie['domain']}\tTRUE\t{cookie['path']}\t{'TRUE' if cookie.get('secure') else 'FALSE'}\t"
                            f"{int(cookie['expires']) if cookie.get('expires') else 0}\t"
                            f"{cookie['name']}\t{cookie['value']}\n")
        logger.info(f"Cookies конвертовано в {cookies_txt}")
        return True
    except json.JSONDecodeError as e:
        logger.error(f"Помилка формату JSON у {cookies_file}: {e}")
        return False
    except Exception as e:
        logger.error(f"Помилка конвертації cookies: {e}", exc_info=True)
        return False

async def generate_cookies_if_needed():
    """Генерує cookies.txt, якщо він відсутній або некоректний."""
    cookies_txt = 'InstaVieverBot/cookies.txt'
    cookies_json = 'InstaVieverBot/cookies.json'

    if os.path.exists(cookies_txt) and os.path.getsize(cookies_txt) > 100:
        logger.info(f"Файл {cookies_txt} уже існує і є дійсним")
        try:
            with open(cookies_txt, 'r') as f:
                content = f.read()
                if 'ttwid' in content and 's_v_web_id' in content:
                    return True
        except Exception as e:
            logger.warning(f"Помилка читання {cookies_txt}: {e}")

    logger.info(f"Перевіряємо наявність {cookies_json}")
    if os.path.exists(cookies_json):
        logger.info(f"Знайдено {cookies_json}, конвертуємо в {cookies_txt}")
        if await convert_cookies_to_netscape():
            return True
        else:
            logger.warning(f"Не вдалося конвертувати {cookies_json}, не видаляємо для діагностики")

    if os.path.exists(cookies_txt):
        logger.info(f"Файл {cookies_txt} порожній або некоректний, видаляємо")
        os.remove(cookies_txt)

    if await generate_cookies_with_login():
        if await convert_cookies_to_netscape():
            return True
    logger.warning("Не вдалося створити cookies.txt. Продовжуємо без cookies.")
    return False

async def resolve_short_url(url: str) -> str:
    """Розгортає коротке посилання (наприклад, vm.tiktok.com) у повне."""
    if 'vm.tiktok.com' not in url:
        return url

    if url in url_cache:
        logger.info(f"URL знайдено в кеші: {url} -> {url_cache[url]}")
        return url_cache[url]

    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.5',
    }
    cookies_json = 'InstaVieverBot/cookies.json'
    cookies = {}
    if os.path.exists(cookies_json):
        try:
            logger.info(f"Завантажуємо cookies з {cookies_json} для httpx")
            cookies = {c['name']: c['value'] for c in json.load(open(cookies_json))['cookies'] if 'tiktok.com' in c['domain']}
        except json.JSONDecodeError as e:
            logger.error(f"Помилка формату JSON у {cookies_json}: {e}")
            cookies = {}

    async def try_httpx():
        async with httpx.AsyncClient(follow_redirects=True, timeout=5) as client:
            try:
                response = await client.get(url, headers=headers, cookies=cookies)
                resolved_url = str(response.url)
                logger.info(f"Розгорнуте коротке посилання (httpx): {url} -> {resolved_url}")
                if '/video/' in resolved_url:
                    return resolved_url
                html_content = response.text
                video_url_match = re.search(r'https://www\.tiktok\.com/@[\w\.-]+/video/\d+', html_content) or \
                                  re.search(r'"url":[](https://www\.tiktok\.com/@[\w\.-]+/video/\d+)"', html_content)
                if video_url_match:
                    resolved_url = video_url_match.group(0) if video_url_match.group(0).startswith('http') else video_url_match.group(1)
                    logger.info(f"Знайдено URL у HTML (httpx): {resolved_url}")
                    return resolved_url
                logger.warning("Не знайдено URL відео в HTML (httpx)")
                return None
            except httpx.HTTPError as e:
                logger.warning(f"Помилка httpx при розгортанні URL {url}: {e}")
                return None

    async def try_playwright():
        try:
            async with async_playwright() as p:
                browser = await p.chromium.launch(headless=True)
                context = await browser.new_context(
                    user_agent=headers['User-Agent'],
                    extra_http_headers=headers
                )
                if cookies:
                    logger.info(f"Завантажуємо cookies з {cookies_json} для Playwright")
                    await context.add_cookies(json.load(open(cookies_json))['cookies'])
                page = await context.new_page()
                await page.goto(url, timeout=30000, wait_until='domcontentloaded')
                resolved_url = page.url
                logger.info(f"Розгорнуте коротке посилання (playwright): {url} -> {resolved_url}")
                if '/video/' in resolved_url:
                    await context.close()
                    await browser.close()
                    return resolved_url
                await page.wait_for_timeout(2000)  # Зменшено затримку до 2 секунд
                html_content = await page.content()
                video_url_match = re.search(r'https://www\.tiktok\.com/@[\w\.-]+/video/\d+', html_content) or \
                                  re.search(r'"url":[](https://www\.tiktok\.com/@[\w\.-]+/video/\d+)"', html_content)
                await context.close()
                await browser.close()
                if video_url_match:
                    resolved_url = video_url_match.group(0) if video_url_match.group(0).startswith('http') else video_url_match.group(1)
                    logger.info(f"Знайдено URL у HTML (playwright): {resolved_url}")
                    return resolved_url
                logger.warning("Playwright не знайшов коректний URL відео")
                return None
        except PlaywrightTimeoutError:
            logger.warning(f"Playwright: Таймаут при розгортанні URL {url}")
            return None
        except Exception as e:
            logger.warning(f"Помилка playwright при розгортанні URL {url}: {e}")
            return None

    # Паралельне виконання httpx і playwright
    results = await asyncio.gather(try_httpx(), try_playwright(), return_exceptions=True)
    for result in results:
        if isinstance(result, str) and '/video/' in result:
            url_cache[url] = result
            return result
    raise ValueError("Не вдалося знайти URL відео в HTML")

async def download_tiktok_playwright(url: str) -> tuple[bool, str, str]:
    """Завантажує відео через Playwright, якщо yt-dlp не спрацював."""
    start_time = time.time()
    try:
        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=True)
            context = await browser.new_context(
                user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            )
            cookies_json = 'InstaVieverBot/cookies.json'
            if os.path.exists(cookies_json):
                try:
                    logger.info(f"Завантажуємо cookies з {cookies_json} для Playwright")
                    await context.add_cookies(json.load(open(cookies_json))['cookies'])
                except json.JSONDecodeError as e:
                    logger.error(f"Помилка формату JSON у {cookies_json}: {e}")
            page = await context.new_page()
            await page.goto(url, timeout=30000, wait_until='domcontentloaded')
            video_element = await page.query_selector('video')
            if not video_element:
                await context.close()
                await browser.close()
                return False, "", "Не знайдено відео на сторінці або контент недоступний"
            video_url = await video_element.get_attribute('src')
            if not video_url:
                await context.close()
                await browser.close()
                return False, "", "Не вдалося отримати URL відео"
            
            async with httpx.AsyncClient() as client:
                response = await client.get(video_url, timeout=10)
                if response.status_code != 200:
                    await context.close()
                    await browser.close()
                    return False, "", f"Помилка завантаження відео: HTTP {response.status_code}"
                
                output_path = f'InstaVieverBot/temp_video_{hash(url)}_playwright.mp4'
                with open(output_path, 'wb') as f:
                    f.write(response.content)
                
                if os.path.getsize(output_path) > 50 * 1024 * 1024:
                    logger.info("Файл занадто великий (>50 МБ), стискаємо")
                    compressed_path = output_path.replace('.mp4', '_compressed.mp4')
                    if await compress_video(output_path, compressed_path):
                        os.remove(output_path)
                        output_path = compressed_path
                    else:
                        os.remove(output_path)
                        await context.close()
                        await browser.close()
                        return False, "", "Не вдалося стиснути відео"
                
                await context.close()
                await browser.close()
                logger.info(f"Playwright: Відео збережено як {output_path}")
                logger.info(f"Час виконання Playwright для {url}: {time.time() - start_time:.2f} секунд")
                return True, output_path, ""
    except PlaywrightTimeoutError:
        logger.error(f"Playwright: Таймаут при завантаженні відео {url}")
        return False, "", "Таймаут при завантаженні відео"
    except Exception as e:
        logger.error(f"Помилка Playwright при завантаженні відео {url}: {e}", exc_info=True)
        return False, "", f"Помилка завантаження через Playwright: {str(e)}"

async def compress_video(input_path: str, output_path: str) -> bool:
    """Стискає відео, якщо воно більше 50 МБ."""
    try:
        stream = ffmpeg.input(input_path)
        stream = ffmpeg.output(stream, output_path, vcodec='libx264', acodec='aac', video_bitrate='1M', audio_bitrate='128k', format='mp4')
        ffmpeg.run(stream, overwrite_output=True, quiet=True)
        logger.info(f"Відео стиснуто: {output_path}")
        return True
    except Exception as e:
        logger.error(f"Помилка стиснення відео: {e}")
        return False

async def download_tiktok_ytdlp(url: str, use_cookies: bool = True) -> tuple[bool, str, str]:
    """Завантажує відео з TikTok через yt-dlp."""
    start_time = time.time()
    try:
        output_template = f'InstaVieverBot/temp_video_{hash(url)}_ytdlp.%(ext)s'
        ydl_opts = {
            'outtmpl': output_template,
            'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
            'quiet': False,
            'noplaylist': True,
            'merge_output_format': 'mp4',
        }
        cookies_txt = 'InstaVieverBot/cookies.txt'
        if use_cookies and os.path.exists(cookies_txt):
            ydl_opts['cookiefile'] = cookies_txt
            logger.info(f"Використовуємо {cookies_txt}")
        logger.info(f"yt-dlp: Починаємо завантаження для {url}")
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            video_path = ydl.prepare_filename(info)
            logger.info(f"yt-dlp: Відео збережено як {video_path}")

            if os.path.getsize(video_path) > 50 * 1024 * 1024:
                logger.info("Файл занадто великий (>50 МБ), стискаємо")
                compressed_path = video_path.replace('.mp4', '_compressed.mp4')
                if await compress_video(video_path, compressed_path):
                    os.remove(video_path)
                    video_path = compressed_path
                else:
                    os.remove(video_path)
                    return False, "", "Не вдалося стиснути відео"

            logger.info(f"Час виконання yt-dlp для {url}: {time.time() - start_time:.2f} секунд")
            return True, video_path, ""
    except yt_dlp.utils.DownloadError as e:
        logger.error(f"yt-dlp: Помилка завантаження: {e}", exc_info=True)
        if "This video is private" in str(e):
            return False, "", "Це відео приватне або обмежене."
        elif "Your IP address is blocked" in str(e):
            return False, "", "IP_BLOCK"
        elif "Unsupported URL" in str(e):
            return False, "", "Непідтримуваний URL. Перевірте правильність посилання."
        elif "No video formats found" in str(e):
            return False, "", "Не знайдено відео форматів. Можливо, відео недоступне."
        return False, "", f"Помилка завантаження: {str(e)}"
    except Exception as e:
        logger.error(f"yt-dlp: Інша помилка: {e}", exc_info=True)
        return False, "", f"Помилка: {str(e)}"

async def download_tiktok_video(url: str) -> tuple[bool, str, str]:
    """Спробує завантажити відео з TikTok через yt-dlp або Playwright."""
    start_time = time.time()
    logger.info(f"Починаємо завантаження відео для URL: {url}")
    
    try:
        clean_url = await resolve_short_url(url)
    except ValueError as e:
        logger.error(f"Помилка розгортання URL: {e}")
        return False, "", str(e)
    clean_url = re.sub(r'\?.*', '', clean_url)
    if clean_url.startswith('tts://'):
        clean_url = 'https://' + clean_url[4:]
    logger.info(f"Очищений URL: {clean_url}")

    # Спроба 1: yt-dlp без cookies
    success, video_path, error = await download_tiktok_ytdlp(clean_url, use_cookies=False)
    if success:
        logger.info(f"Час виконання для {url}: {time.time() - start_time:.2f} секунд")
        return True, video_path, ""

    # Спроба 2: yt-dlp з cookies
    if await generate_cookies_if_needed():
        success, video_path, error = await download_tiktok_ytdlp(clean_url, use_cookies=True)
        if success:
            logger.info(f"Час виконання для {url}: {time.time() - start_time:.2f} секунд")
            return True, video_path, ""

    # Спроба 3: Playwright, якщо IP заблоковано
    if error == "IP_BLOCK":
        logger.info("Спроба завантаження через Playwright через блокування IP")
        success, video_path, error = await download_tiktok_playwright(clean_url)
        if success:
            logger.info(f"Час виконання для {url}: {time.time() - start_time:.2f} секунд")
            return True, video_path, ""
        error = f"Не вдалося завантажити відео: {error}"

    logger.info(f"Час виконання для {url}: {time.time() - start_time:.2f} секунд")
    return False, "", error

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    message_text = update.message.text
    logger.info(f"Отримано повідомлення: {message_text}")
    tiktok_pattern = r'(https?://|tts://)?((?:www\.)?(?:tiktok\.com|vm\.tiktok\.com)/(?:@[\w\.-]+/video/\d+|[\w\d]+)(?:\?.*)?)'
    if not re.match(tiktok_pattern, message_text):
        logger.info("Посилання не відповідає формату TikTok")
        await update.message.reply_text("Будь ласка, надішли дійсне посилання на TikTok!")
        return
    logger.info("Надсилаємо повідомлення про початок завантаження")
    await update.message.reply_text("Завантажую відео, зачекай...")
    logger.info("Викликаємо download_tiktok_video")
    success, video_path, error = await download_tiktok_video(message_text)
    logger.info(f"Результат завантаження: success={success}, video_path={video_path}, error={error}")
    if not success:
        logger.info("Надсилаємо повідомлення про помилку")
        await update.message.reply_text(f"Не вдалося завантажити відео: {error}")
        return
    try:
        logger.info(f"Надсилаємо відео: {video_path}")
        with open(video_path, 'rb') as video_file:
            await update.message.reply_video(video=video_file)
        os.remove(video_path)
        logger.info(f"Відео успішно надіслано для {message_text}")
    except Exception as e:
        logger.error(f"Помилка надсилання відео: {e}", exc_info=True)
        await update.message.reply_text("Помилка при надсиланні відео")
        if os.path.exists(video_path):
            os.remove(video_path)

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.error(f"Update {update} caused error {context.error}", exc_info=True)
    await update.message.reply_text("Виникла помилка. Спробуй ще раз!")

def main() -> None:
    token = os.getenv('BOT_TOKEN_TIKTOK')
    if not token:
        logger.error("BOT_TOKEN_TIKTOK не встановлено")
        return
    logger.info("Ініціалізація бота з BOT_TOKEN_TIKTOK")
    application = Application.builder().token(token).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_error_handler(error_handler)
    logger.info("Запуск polling...")
    try:
        application.run_polling(allowed_updates=Update.ALL_TYPES, drop_pending_updates=True)
    except Exception as e:
        logger.error(f"Помилка під час polling: {e}", exc_info=True)
    finally:
        logger.info("Зупинка бота...")

if __name__ == "__main__":
    logger.info("Запуск бота...")
    try:
        main()
    except Exception as e:
        logger.error(f"Помилка запуску: {e}", exc_info=True)
