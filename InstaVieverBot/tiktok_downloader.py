import os
import re
import logging
import yt_dlp
import httpx
import asyncio
from playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeoutError
import ffmpeg
import json
import time
import tempfile

logger = logging.getLogger(__name__)

url_cache = {}

async def generate_cookies_with_login():
    """Генерує cookies через авторизацію за логіном і паролем."""
    username = os.getenv('TIKTOK_USERNAME')
    password = os.getenv('TIKTOK_PASSWORD')
    if not username or not password:
        logger.warning("TIKTOK_USERNAME або TIKTOK_PASSWORD не встановлено")
        return False

    logger.info("Генеруємо cookies через авторизацію")
    try:
        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=False)
            context = await browser.new_context(
                user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            )
            page = await context.new_page()
            await page.goto('https://www.tiktok.com/login/phone-or-email/email', timeout=60000)
            await page.wait_for_load_state('networkidle', timeout=60000)
            logger.info("Заповнюємо форму логіну")
            await page.fill('input[name="username"]', username)
            await page.fill('input[name="password"]', password)
            await page.click('button[type="submit"]')
            await page.wait_for_timeout(10000)
            if 'login' in page.url:
                logger.error("Авторизація не вдалася, можливо, потрібна CAPTCHA")
                await page.screenshot(path='InstaVieverBot/login_screenshot.png')
                await browser.close()
                return False
            await context.storage_state(path='InstaVieverBot/cookies.json')
            await browser.close()
            logger.info("Cookies успішно збережено в InstaVieverBot/cookies.json")
            return True
    except PlaywrightTimeoutError:
        logger.error("Таймаут під час авторизації через Playwright")
        return False
    except Exception as e:
        logger.error(f"Помилка під час авторизації через Playwright: {e}", exc_info=True)
        return False

async def convert_cookies_to_netscape(cookies_json='InstaVieverBot/cookies.json', cookies_txt='InstaVieverBot/cookies.txt'):
    """Конвертує cookies.json у формат Netscape для yt-dlp."""
    if not os.path.exists(cookies_json):
        logger.warning(f"Файл {cookies_json} не знайдено")
        return False

    try:
        with open(cookies_json, 'r') as f:
            data = json.load(f)
            cookies = data.get('cookies', [])
            if not cookies:
                logger.warning(f"Файл {cookies_json} порожній або не містить cookies")
                return False
        with open(cookies_txt, 'w') as f:
            f.write('# Netscape HTTP Cookie File\n# This file is generated by the bot. Do not edit.\n\n')
            for cookie in cookies:
                if cookie.get('domain') and 'tiktok.com' in cookie['domain']:
                    f.write(f"{cookie['domain']}\tTRUE\t{cookie['path']}\t{'TRUE' if cookie.get('secure') else 'FALSE'}\t"
                            f"{int(cookie['expires']) if cookie.get('expires') else 0}\t"
                            f"{cookie['name']}\t{cookie['value']}\n")
        logger.info(f"Cookies конвертовано в {cookies_txt}")
        return True
    except json.JSONDecodeError as e:
        logger.error(f"Помилка формату JSON у {cookies_json}: {e}")
        return False
    except Exception as e:
        logger.error(f"Помилка конвертації cookies: {e}", exc_info=True)
        return False

async def generate_cookies_if_needed():
    """Генерує cookies.txt, якщо він відсутній або некоректний."""
    cookies_txt = 'InstaVieverBot/cookies.txt'
    cookies_json = 'InstaVieverBot/cookies.json'

    if os.path.exists(cookies_txt) and os.path.getsize(cookies_txt) > 100:
        logger.info(f"Файл {cookies_txt} уже існує і є дійсним")
        try:
            with open(cookies_txt, 'r') as f:
                content = f.read()
                if 'ttwid' in content and 's_v_web_id' in content and 'sessionid' in content:
                    return True
        except Exception as e:
            logger.warning(f"Помилка читання {cookies_txt}: {e}")

    logger.info(f"Перевіряємо наявність {cookies_json}")
    if os.path.exists(cookies_json):
        logger.info(f"Знайдено {cookies_json}, конвертуємо в {cookies_txt}")
        if await convert_cookies_to_netscape():
            return True
        else:
            logger.warning(f"Не вдалося конвертувати {cookies_json}, не видаляємо для діагностики")

    if os.path.exists(cookies_txt):
        logger.info(f"Файл {cookies_txt} порожній або некоректний, видаляємо")
        os.remove(cookies_txt)

    if await generate_cookies_with_login():
        if await convert_cookies_to_netscape():
            return True
    logger.warning("Не вдалося створити cookies.txt. Продовжуємо без cookies.")
    return False

async def resolve_short_url(url: str) -> str:
    """Розгортає коротке посилання (наприклад, vm.tiktok.com) у повне."""
    if 'vm.tiktok.com' not in url:
        return url

    if url in url_cache:
        logger.info(f"URL знайдено в кеші: {url} -> {url_cache[url]}")
        return url_cache[url]

    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.5',
    }
    cookies_json = 'InstaVieverBot/cookies.json'
    cookies = {}
    if os.path.exists(cookies_json):
        try:
            logger.info(f"Завантажуємо cookies з {cookies_json} для httpx")
            cookies = {c['name']: c['value'] for c in json.load(open(cookies_json))['cookies'] if 'tiktok.com' in c['domain']}
        except json.JSONDecodeError as e:
            logger.error(f"Помилка формату JSON у {cookies_json}: {e}")
            cookies = {}

    async def try_httpx():
        async with httpx.AsyncClient(follow_redirects=True, timeout=5) as client:
            try:
                response = await client.get(url, headers=headers, cookies=cookies)
                resolved_url = str(response.url)
                logger.info(f"Розгорнуте коротке посилання (httpx): {url} -> {resolved_url}")
                if '/video/' in resolved_url:
                    return resolved_url
                html_content = response.text
                video_url_match = re.search(r'https://www\.tiktok\.com/@[\w\.-]+/video/\d+', html_content) or \
                                  re.search(r'"url":[](https://www\.tiktok\.com/@[\w\.-]+/video/\d+)"', html_content)
                if video_url_match:
                    resolved_url = video_url_match.group(0) if video_url_match.group(0).startswith('http') else video_url_match.group(1)
                    logger.info(f"Знайдено URL у HTML (httpx): {resolved_url}")
                    return resolved_url
                logger.warning("Не знайдено URL відео в HTML (httpx)")
                return None
            except httpx.HTTPError as e:
                logger.warning(f"Помилка httpx при розгортанні URL {url}: {e}")
                return None

    async def try_playwright():
        try:
            async with async_playwright() as p:
                browser = await p.chromium.launch(headless=True)
                context = await browser.new_context(
                    user_agent=headers['User-Agent'],
                    extra_http_headers=headers
                )
                if cookies:
                    logger.info(f"Завантажуємо cookies з {cookies_json} для Playwright")
                    await context.add_cookies(json.load(open(cookies_json))['cookies'])
                page = await context.new_page()
                await page.goto(url, timeout=30000, wait_until='networkidle')
                resolved_url = page.url
                logger.info(f"Розгорнуте коротке посилання (playwright): {url} -> {resolved_url}")
                if '/video/' in resolved_url:
                    await context.close()
                    await browser.close()
                    return resolved_url
                await page.wait_for_timeout(2000)
                html_content = await page.content()
                video_url_match = re.search(r'https://www\.tiktok\.com/@[\w\.-]+/video/\d+', html_content) or \
                                  re.search(r'"url":[](https://www\.tiktok\.com/@[\w\.-]+/video/\d+)"', html_content)
                await context.close()
                await browser.close()
                if video_url_match:
                    resolved_url = video_url_match.group(0) if video_url_match.group(0).startswith('http') else video_url_match.group(1)
                    logger.info(f"Знайдено URL у HTML (playwright): {resolved_url}")
                    return resolved_url
                logger.warning("Playwright не знайшов коректний URL відео")
                return None
        except PlaywrightTimeoutError:
            logger.warning(f"Playwright: Таймаут при розгортанні URL {url}")
            return None
        except Exception as e:
            logger.warning(f"Помилка playwright при розгортанні URL {url}: {e}")
            return None

    results = await asyncio.gather(try_httpx(), try_playwright(), return_exceptions=True)
    for result in results:
        if isinstance(result, str) and '/video/' in result:
            url_cache[url] = result
            return result
    raise ValueError("Не вдалося знайти URL відео в HTML")

async def download_tiktok_playwright(url: str) -> tuple[bool, str, str]:
    """Завантажує відео через Playwright, якщо yt-dlp не спрацював."""
    start_time = time.time()
    try:
        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=True)
            context = await browser.new_context(
                user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            )
            cookies_json = 'InstaVieverBot/cookies.json'
            if os.path.exists(cookies_json):
                try:
                    logger.info(f"Завантажуємо cookies з {cookies_json} для Playwright")
                    await context.add_cookies(json.load(open(cookies_json))['cookies'])
                except json.JSONDecodeError as e:
                    logger.error(f"Помилка формату JSON у {cookies_json}: {e}")
            page = await context.new_page()
            await page.goto(url, timeout=60000, wait_until='networkidle')
            captcha = await page.query_selector('div#captcha-container')
            if captcha:
                logger.error("Виявлено CAPTCHA. Потрібна ручна авторизація.")
                await page.screenshot(path='InstaVieverBot/captcha_screenshot.png')
                await context.close()
                await browser.close()
                return False, "", "Виявлено CAPTCHA. Оновіть cookies після ручної авторизації."
            video_element = await page.query_selector('video')
            if not video_element:
                logger.error("Не знайдено елемент <video> на сторінці")
                html_content = await page.content()
                await page.screenshot(path='InstaVieverBot/error_screenshot.png')
                await context.close()
                await browser.close()
                return False, "", "Не знайдено відео на сторінці або контент недоступний"
            video_url = await video_element.get_attribute('src')
            if not video_url:
                logger.error("Не вдалося отримати URL відео")
                await context.close()
                await browser.close()
                return False, "", "Не вдалося отримати URL відео"
            
            async with httpx.AsyncClient() as client:
                response = await client.get(video_url, timeout=10)
                if response.status_code != 200:
                    await context.close()
                    await browser.close()
                    return False, "", f"Помилка завантаження відео: HTTP {response.status_code}"
                
                output_path = f'InstaVieverBot/temp/temp_video_{hash(url)}_playwright.mp4'
                with open(output_path, 'wb') as f:
                    f.write(response.content)
                
                if os.path.getsize(output_path) > 50 * 1024 * 1024:
                    logger.info("Файл занадто великий (>50 МБ), стискаємо")
                    compressed_path = output_path.replace('.mp4', '_compressed.mp4')
                    if await compress_video(output_path, compressed_path):
                        os.remove(output_path)
                        output_path = compressed_path
                    else:
                        os.remove(output_path)
                        await context.close()
                        await browser.close()
                        return False, "", "Не вдалося стиснути відео"
                
                await context.close()
                await browser.close()
                logger.info(f"Playwright: Відео збережено як {output_path}")
                logger.info(f"Час виконання Playwright для {url}: {time.time() - start_time:.2f} секунд")
                return True, output_path, ""
    except PlaywrightTimeoutError:
        logger.error(f"Playwright: Таймаут при завантаженні відео {url}")
        return False, "", "Таймаут при завантаженні відео"
    except Exception as e:
        logger.error(f"Помилка Playwright при завантаженні відео {url}: {e}", exc_info=True)
        return False, "", f"Помилка завантаження через Playwright: {str(e)}"

async def compress_video(input_path: str, output_path: str) -> bool:
    """Стискає відео, якщо воно більше 50 МБ."""
    try:
        stream = ffmpeg.input(input_path)
        stream = ffmpeg.output(stream, output_path, vcodec='libx264', acodec='aac', video_bitrate='1M', audio_bitrate='128k', format='mp4')
        ffmpeg.run(stream, overwrite_output=True, quiet=True)
        logger.info(f"Відео стиснуто: {output_path}")
        return True
    except Exception as e:
        logger.error(f"Помилка стиснення відео: {e}")
        return False

async def download_tiktok_ytdlp(url: str, use_cookies: bool = True) -> tuple[bool, str, str]:
    """Завантажує відео з TikTok через yt-dlp."""
    start_time = time.time()
    try:
        output_template = f'InstaVieverBot/temp/temp_video_{hash(url)}_ytdlp.%(ext)s'
        ydl_opts = {
            'outtmpl': output_template,
            'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
            'quiet': False,
            'noplaylist': True,
            'merge_output_format': 'mp4',
        }
        cookies_txt = 'InstaVieverBot/cookies.txt'
        if use_cookies:
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as temp_cookies:
                if os.path.exists(cookies_txt):
                    with open(cookies_txt, 'r') as f:
                        temp_cookies.write(f.read())
                else:
                    await convert_cookies_to_netscape(cookies_txt=temp_cookies.name)
                ydl_opts['cookiefile'] = temp_cookies.name
                logger.info(f"Використовуємо тимчасовий файл cookies: {temp_cookies.name}")
        
        logger.info(f"yt-dlp: Починаємо завантаження для {url}")
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            video_path = ydl.prepare_filename(info)
            logger.info(f"yt-dlp: Відео збережено як {video_path}")

            if os.path.getsize(video_path) > 50 * 1024 * 1024:
                logger.info("Файл занадто великий (>50 МБ), стискаємо")
                compressed_path = video_path.replace('.mp4', '_compressed.mp4')
                if await compress_video(video_path, compressed_path):
                    os.remove(video_path)
                    video_path = compressed_path
                else:
                    os.remove(video_path)
                    return False, "", "Не вдалося стиснути відео"

            if 'cookiefile' in ydl_opts:
                os.remove(ydl_opts['cookiefile'])
            logger.info(f"Час виконання yt-dlp для {url}: {time.time() - start_time:.2f} секунд")
            return True, video_path, ""
    except yt_dlp.utils.DownloadError as e:
        logger.error(f"yt-dlp: Помилка завантаження: {e}", exc_info=True)
        if 'cookiefile' in ydl_opts:
            os.remove(ydl_opts['cookiefile'])
        if "This video is private" in str(e):
            return False, "", "Це відео приватне або обмежене."
        elif "Your IP address is blocked" in str(e):
            return False, "", "Ваш IP-адресу заблоковано для цього відео."
        return False, "", f"Помилка yt-dlp: {str(e)}"
    except Exception as e:
        logger.error(f"Помилка yt-dlp для {url}: {e}", exc_info=True)
        if 'cookiefile' in ydl_opts:
            os.remove(ydl_opts['cookiefile'])
        return False, "", f"Помилка: {str(e)}"

async def download_tiktok(url: str) -> tuple[bool, str, str]:
    """Основна функція для завантаження TikTok відео."""
    await generate_cookies_if_needed()
    try:
        resolved_url = await resolve_short_url(url)
        success, file_path, error = await download_tiktok_ytdlp(resolved_url)
        if success:
            return success, file_path, error
        logger.info("Спроба завантаження через Playwright через помилку yt-dlp")
        return await download_tiktok_playwright(resolved_url)
    except Exception as e:
        logger.error(f"Помилка завантаження TikTok {url}: {e}", exc_info=True)
        return False, "", f"Помилка: {str(e)}"
